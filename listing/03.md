```go
package main
 
import (
    "fmt"
    "os"
)
 
func Foo() error {
    var err *os.PathError = nil
    return err
}
 
func main() {
    err := Foo()
    fmt.Println(err)
    fmt.Println(err == nil)
}

```
Программа выведет
- nil
- false

Это происходит вследствие того, что функция `foo` возвращает тип `error`, а когда мы возвращаем переменную `err`, у нас происходит неявное приведение типа к `error`. `error` представляет собой интерфейсный тип.
Под капотом интерфейс представляет собой структуру `iface`, которая содержит в себе два поля `itab` и `idata`. `itab` представляет собой указатель на метаданные, `idata` - указатель на само значение данных. 
Утверждение, что интерфейс является `nil`-интерфейсом возможно тогда и только тогда, когда оба этих поля являются `nil`. В нашем же случае в `itab` будет указано, что тип переменной `*os.PathError`. Поэтому сравнение на `nil` вернёт `false`.
Что касается пустого интерфейса, то под капотом он представляет собой структуру `eface`, в ней содержится два поля `idata` и `_type` - указатель на тип данных, так как пустой интерфейс не описывает методов, то и хранить таблицу под них не имеет смысла 
